<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MIT6.824 2020 Lab1 MapReduce 实现]]></title>
    <url>%2F2021%2F03%2F12%2FMIT6-824-2020-Lab1-MapReduce-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[准备工作实验地址：http://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html 论文地址：mapreduce 实验环境可以在实验地址里面找到具体的搭建方式。 系统总览MapReduce 系统是由一个 master 进程和多个 worker 进程组成。 Master 负责任务状态的记录以及任务的分发。 Worker 负责不断向 master 请求任务，并根据任务的类型（map/reduce）进行处理，最后将任务结果发送给 master。 系统框架图如下： 系统流程图如下： 程序基本逻辑Master master 一开始只能分发 map 任务。 当所有 map 任务执行完毕后，master 才开始分发 reduce 任务。 当所有 map 和 reduce 任务执行完毕，master 退出。 对于分发出去的任务，需要进行超时控制，即超时的任务需要重新分发处理。在完成分发任务的同时，对该任务运行一条检测任务超时的 go routine checkTaskTimeout 。 WorkerWorker 调用 GetTask RPC 接口不断向 master 请求任务。当接收到任务，根据任务的类型分类处理。处理完后，调用 CompleteTask 接口告知 master 任务执行完毕。 如果是 map 任务，输入是单个文件，通过 mapf 处理后，使用 ihash(key) % nReduce 决定写入到哪个中间文件，输出是 nReduce 个中间文件。 如果是 reduce 任务，输入是多个 map 输出的中间文件，通过 reducef 处理后，输出是单个文件。 如果没有可执行的任务，则等待一下，继续轮询。 代码结构Master 的结构如下： 12345678910111213141516171819202122// master.gotype Task struct &#123; // Pending, Running and Completed phase string taskID int taskType string // for map, input path has only one element inputPaths []string // for reduce, output path has only one element outputPaths []string&#125;type Master struct &#123; nReduce int mapTasks []*Task reduceTasks []*Task incompletedMapTaskCount int incompletedReduceTaskCount int reduceInitialized bool mux sync.Mutex&#125; Worker 主要是处理逻辑，官方实验文档以及 main/mrsequential.go 里面有例子。 RPC 的结构如下： 123456789101112131415161718// rpc.gotype GetTaskRequest struct&#123;&#125;type GetTaskResponse struct &#123; TaskType string TaskID int TaskInputs []string NReduce int&#125;type CompleteTaskRequest struct &#123; TaskType string TaskID int TaskOutputs []string&#125;type CompleteTaskResponse struct&#123;&#125; 以上是代码的结构，具体的代码细节在 github 上面。 踩过的坑这里最主要的应该是对于并发的控制，以及 crash 的处理。 并发控制加锁可以完成。 crash 的处理是靠 master 的超时机制，以及在 worker 处理的时候，生成一个临时文件，在处理结束后再 rename 成最终的文件。 为了方便 debug，推荐使用 github.com/sirupsen/logrus 这个库。可以将 debug 等级设为 debug level 来输出自己的 debug 信息。 12345678910import ( log "github.com/sirupsen/logrus")log.SetOutput(os.Stdout)// log.SetLevel(log.DebugLevel)log.SetLevel(log.WarnLevel)log.SetFormatter(&amp;log.TextFormatter&#123; FullTimestamp: true,&#125;) 最终结果 这里的 FATAL 是 master 检测到所有任务完成后退出，worker 连接不上 master 而抛出的错误，是预期的。 结语这个实验虽然只是一个小玩具，但还是有收获的。特别是看过论文后进行实验，对 mapreduce 一些细节的实现有更深的了解。有兴趣的同学可以自己完成一遍。]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的协程]]></title>
    <url>%2F2020%2F04%2F05%2FPython%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是协程协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。 协程是程序可以控制的，可以在内部中断。 生成器与协程从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。但是在协程中， yield 通常会出现在表达式的右边，例如 value = yeild ，可以选择是否产出值，如果 yield 后面没有表达式，那么生成器产出 None。 协程通常包含着协程本身与调用方的数据交互，因此协程可能会从调用方接收数据，不过调用方把数据提供给协程的方式是通过 coroutine.send(value) 方法，而不是 next(coroutinue) 函数。除了 .send(value) 方法之外，还有 .throw(Exception) 和 .close() 方法：前者的作用是让调用方抛出异常，在生成器中处理；后者的作用是终止生成器。 Python 中协程的使用方式本文使用的 Python 环境是 Python3.7.1 。 有了上面的知识，可以写出我们的第一个使用协程的简单例子。 Example 1 123456789101112131415&gt;&gt;&gt; def my_coroutine():... print('start')... value = yield # 这里 value 会接收协程调用方使用 `.send()` 发送的值... print(f'received &#123;value&#125;')... &gt;&gt;&gt; my_coro = my_coroutine()&gt;&gt;&gt; my_coro&lt;generator object my_coroutine at 0x10165bc78&gt;&gt;&gt;&gt; next(my_coro) # 预激协程start&gt;&gt;&gt; my_coro.send("233") # 将值传给协程received 233Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration 协程的状态协程具有四个状态，分别是： GEN_CREATED 等待开始执行。 GEN_RUNNING 解释器正在执行。 GEN_SUSPENDED 在 yield 表达式处暂停。 GEN_CLOSED 执行结束。 要获取协程的状态可以通过 inspect.getgeneratorstate(coroutine) 方法获取。 一开始的时候，协程还处于未激活状态 GEN_CREATED，这时需要使用 next(coroutine) 或者 coroutine.send(None) 方法激活协程。这一步通常叫做 预激(prime) 协程（即让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）。 Tips：如果没有预激协程，那么会抛出一个异常，如下： Example 2 123456789101112131415&gt;&gt;&gt; def my_coroutine():... print('start')... import time... time.sleep(5)... x = yield... print(f'end -&gt; &#123;x&#125;')... &gt;&gt;&gt; coro = my_coroutine()&gt;&gt;&gt; import inspect&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_CREATED&gt;&gt;&gt; coro.send("233")Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can't send non-None value to a just-started generator 由于 .send() 方法的参数会成为暂停的 yield 表达式的值，所以仅当协程处于暂停状态时才可以调用 sned 方法，换句话说，调用方在使用 .send() 方法的时候可能会阻塞主程序的运行。例如我们尝试在协程中加上 sleep() 。 Example 3 1234567891011121314151617&gt;&gt;&gt; def my_coroutine():... print('start')... import time... time.sleep(5) # 这里会阻塞主程序 5s... print('sleep 5 ok')... x = yield... print(f'end -&gt; &#123;x&#125;')... &gt;&gt;&gt; &gt;&gt;&gt; coro = my_coroutine()&gt;&gt;&gt; print(coro)&lt;generator object my_coroutine at 0x10a0482a0&gt;&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_CREATED&gt;&gt;&gt; next(coro)startsleep 5 ok # 5s 后输出 Eample 4 产出多个值 123456789101112131415161718192021222324252627&gt;&gt;&gt; def my_coroutine2(a):... print(f'start: a = &#123;a&#125;')... b = yield a... print(f'b = &#123;b&#125;')... c = yield a + b... print(f'c = &#123;c&#125;')... &gt;&gt;&gt; &gt;&gt;&gt; coro = my_coroutine2(1)&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_CREATED&gt;&gt;&gt; next(coro)start: a = 11&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_SUSPENDED&gt;&gt;&gt; coro.send(3) # 把数值 3 发给协程，b 被赋值为 3，计算 `a + b`，得到 4, 产出 `a + b` 的值b = 34&gt;&gt;&gt; coro.send(5)c = 5Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt; &gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_CLOSED my_coroutine2() 的执行分为三个阶段： 调用 next(coro)，打印第一个消息，然后执行 yield a，产出 1. 调用 coro.send(3)，把值 3 赋予 b，打印第二个消息，然后执行 yield a + b, 产出 4. 调用 coro.send(5)，把值 5 赋予 c，打印第三个消息，协程终止。 协程的终止与异常处理协程的终止可以调用 coroutine.close() 方法。close() 是会让生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常指运行到结尾），调用方不会报错。 要在协程中抛出异常可以调用 coroutine.throw(...) 方法。throw() 会使生成器在暂停的 yield 表达式处抛出指定异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 throw() 方法得到的返回值。 Example 5 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; class CustomException(Exception):... pass... &gt;&gt;&gt; &gt;&gt;&gt; def my_coroutine3():... print('my coroutine3 start...')... while True:... try:... value = yield... except CustomException:... print('Catch custom exception...')... else:... print(f'coroutine3 received value: &#123;value&#125;')... print('coroutine3 terminated by unknown exception...')... &gt;&gt;&gt; &gt;&gt;&gt; coro = my_coroutine3()&gt;&gt;&gt; next(coro)my coroutine3 start...&gt;&gt;&gt; coro.send(5)coroutine3 received value: 5&gt;&gt;&gt; coro.send(20)coroutine3 received value: 20&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_SUSPENDED&gt;&gt;&gt; coro.throw(CustomException())Catch custom exception...&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_SUSPENDED&gt;&gt;&gt; coro.close()&gt;&gt;&gt; print(inspect.getgeneratorstate(coro))GEN_CLOSED 获取协程的返回值Example 6 尝试在协程的最后添加 return 语句返回结果。 Example 6 12345678910111213141516171819202122232425&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; &gt;&gt;&gt; Result = namedtuple('Result', 'count average')&gt;&gt;&gt; &gt;&gt;&gt; def averager():... total = 0.0... count = 0... average = None... while True:... value = yield... if value is None:... break... total += value... count += 1... average = total / count... return Result(count, average)... &gt;&gt;&gt; coro = averager()&gt;&gt;&gt; next(coro)&gt;&gt;&gt; coro.send(5)&gt;&gt;&gt; coro.send(20)&gt;&gt;&gt; coro.send(None)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration: Result(count=2, average=12.5) 可以看到协程 return 的值保存在了 StopIteration 的 value 属性中。 于是我们可以修改 Example 6 得到 Example 7, 通过捕获异常去获取返回值： Example 7 1234567891011&gt;&gt;&gt; coro = averager()&gt;&gt;&gt; next(coro)&gt;&gt;&gt; coro.send(5)&gt;&gt;&gt; coro.send(20)&gt;&gt;&gt; try:... coro.send(None)... except StopIteration as e:... result = e.value... &gt;&gt;&gt; print(result)Result(count=2, average=12.5) 这样的程序的缺点很明显，即我们需要添加更多的异常处理。 yield from 可以解决这个问题。 yield fromyield from 会在内部自动捕获 StopIteration 异常，并把异常的 value 属性的值变成 yield from 表达式的值。 举个例子：现在我们有一个动态获取求一组数据的平均结果的需求。 不使用 yield from 的写法如 Example 8 所示。 Example 8 不使用 yield from 12345678910111213141516171819202122232425262728293031323334353637def averager(): total = 0.0 count = 0 average = None while True: value = yield average if value is None: break total += value count += 1 average = total / count return Result(count, average)def main(): data = &#123; "A": [i for i in range(4, 7)], "B": [i for i in range(3)], &#125; results = &#123;&#125; for key, values in data.items(): avg = averager() next(avg) # 预激 group 协程 for value in values: avg.send(value) try: avg.send(None) except StopIteration as e: # catch exception results[key] = e.value print(results)main()===▶ python3 test.py&#123;'A': Result(count=3, average=5.0), 'B': Result(count=3, average=1.0)&#125; 使用 yield from 的代码如 Example 9 所示： Example 9 使用 yield from 123456789101112131415161718192021222324252627282930313233343536373839404142434445from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): total = 0.0 count = 0 average = None while True: value = yield # value 的值是调用方 main() 中 send 过来的 if value is None: break total += value count += 1 average = total / count return Result(count, average)def grouper(results, key): while True: # Tag results[key] = yield from averager()def main(): data = &#123; "A": [i for i in range(50)], "B": [i for i in range(100)], &#125; results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) next(group) # 预激 group 协程 for value in values: group.send(value) group.send(None) # 终止 averager，处理下一个 key 的 values print(results)main()===▶ python3 test.py&#123;'A': Result(count=3, average=5.0), 'B': Result(count=3, average=1.0)&#125; 使用 yield from 会涉及到下面的术语： 委派生成器：包含 yield from &lt;iterable&gt; 表达式的生成器函数。即 grouper()。 子生成器：从 yield from 表达式中 &lt;iterable&gt; 部分获取的生成器。即 averager()。 调用方：调用委派生成器的客户端代码。即 main()。 yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器链接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程添加大量处理异常的样板代码。 Qustion: 为什么在 grouper() 里面需要加 while True 呢？ Answer：由于我们在最后 send(None) 的时候，averager() 直接 break 了，这时候没有再执行到 value = yield 的 yield 处，因此调用方 group.send(None) 拿不到子生成器中 yield 的值，会抛出 StopIteration 异常。我们需要让调用方 group.send(None) 能够拿到 yield 的结果，因此需要再进入子生成器 yield 产出结果给调用方 group.send(None)。 当然 yield from 不只处理了 StopIteration 异常，它还会做一些其他操作，这里是 PEP 380 说明的 yield from 的行为： 子生成器产生的值都返回给委派生成器的调用方。 任何使用 send() 方法发送给委派生成器的值都直接传给子生成器。如果发送的值是 None ，那么会调用子生成器的 __next__() 方法。如果发送的值不是 None，那么会调用子生成器的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复执行，其他任何异常都会向上传递给委派生成器。 除了 GeneratorExit 异常以外的其他传入委派生成器的异常，都会传给子生成器的 throw() 方法。如果调用 throw() 方法时抛出 StopIteration 异常，委派生成器恢复运行。 StopIteration 以外的异常都会向上传递给委派生成器。 如果 GeneratorExit 异常被抛给委派生成器，或者委派生成器的 close() 方法被调用，如果子生成器有 close() 的话也将被调用。如果 close() 调用产生异常，异常将传递给委派生成器。否则，委派生成器将抛出 GeneratorExit 异常。 yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。 生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。 ReferencesFluent Python 本文几乎都是基于这本书的内容做的笔记。 Python Developer’s Guide PEP 380]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的文本和字节]]></title>
    <url>%2F2019%2F09%2F15%2FPython%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%2F</url>
    <content type="text"><![CDATA[概述最近工作中的项目同时使用到了 Python2 和 Python3 ，遇到了文本和字节的 tricks，自己之前对这方面不太了解，学习并总结一下。 编码介绍Unicode 标准Unicode 是用于表示文本以供计算机进行处理的通用字符编码标准。Unicode 标准提供了一种对多语种纯文本进行一致编码的方法，便于国际文本文件的交换。 字符 的最佳定义是 Unicode 字符 。Unicode 只是一个符号集，它只规定了符号的二进制代码，并没有规定这个二进制代码应该如何存储。 UTF-8UTF-8 字符编码是 Unicode 的实现方式之一。 UTF-8 是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 Python 中的文本和字节Python3 中从 str 对象中获取的元素就是 Unicode 字符，可以通过 编码 (encode) 将 文本 转化为 字节。 然而 Python2 中从 str 对象中获取的元素是字节序列，只有通过 解码 (decode) 才能将 字节 转化为 文本 。 下面使用两个版本的 Python 对字符串进行操作以作解释： 123456789# py3&gt;&gt;&gt; s = '123'&gt;&gt;&gt; type(s)&lt;class 'str'&gt; # 文本&gt;&gt;&gt; b = s.encode('utf-8')&gt;&gt;&gt; bb'123'&gt;&gt;&gt; type(b)&lt;class 'bytes'&gt; # 字节序列 12345678910111213141516# py2&gt;&gt;&gt; s = '123'&gt;&gt;&gt; type(s)&lt;type 'str'&gt; # 这里是字节序列&gt;&gt;&gt; b = s.encode('utf-8')&gt;&gt;&gt; b'123'&gt;&gt;&gt; type(b)&lt;type 'str'&gt; # 这里还是字节序列&gt;&gt;&gt; b.decode() # decode 出来的才是文本u'123'&gt;&gt;&gt; type(b.decode())&lt;type 'unicode'&gt; # 文本&gt;&gt;&gt; c = '一二三'&gt;&gt;&gt; c'\xe4\xb8\x80\xe4\xba\x8c\xe4\xb8\x89' # 字节序列 从上面的程序可以总结出 Python2 和 Python3 对于字符串处理上的区别： Python2 Python3 Unicode strings unicode str Bytes strings str bytes Python 中的 u, b, rPython 的字符串有时候前面会加一个 u ，r 或者 b ，其含义如下： u ：表示字符串中的元素是 Unicode 字符。结合上面表格的结论，可以认为：在 Python3 中，字符串前面是否加 u 的效果是一致的。在 Python2 中，字符串前面加 u 表示其中的元素是 Unicode 字符，不加 u 表示 bytes。 b ：表示字符串中的元素是 Bytes。同结合上面表格的结论，可以认为：在 Python2 中，字符串前面是否加 b 的效果是一致的。在 Python3 中，字符串前面加 b 表示其中的元素是 bytes，不加 b 表示 Unicode 字符。 r ：表示字符串是 原始字符串(raw string) ，里面的字符都是 raw string literals ，与 Unicode 和 Bytes 无关，因此 Python2 和 Python3 中含义是一致的。它的作用是使解释器不会对诸如 \n, \t 等转义字符进行转义： 1234567# py3&gt;&gt;&gt; s1 = '123\n123\t123'&gt;&gt;&gt; s1'123\n123\t123'&gt;&gt;&gt; s2 = r'123\n123\t123'&gt;&gt;&gt; s2'123\\n123\\t123' # 不转义 Python2 和 Python3 在字符串处理方面的兼容既然 Python2 和 Python3 在字符串的处理方面有所不同，但是实际工作中却需要写出兼容两种版本的代码，那么应该如何处理呢？ 我的做法是使用 __future__ 模块： 1from __future__ import unicode_literals 该模块的作用是将 Python2 的字符串字面量的类型变为文本，而不是字节，因此与 Python3 是一样的。 举个栗子： 123456789101112# py2&gt;&gt;&gt; from __future__ import unicode_literals&gt;&gt;&gt; s = '123'&gt;&gt;&gt; su'123'&gt;&gt;&gt; type(s)&lt;type 'unicode'&gt; # 文本&gt;&gt;&gt; b = b'123'&gt;&gt;&gt; b'123'&gt;&gt;&gt; type(b)&lt;type 'str'&gt; # 字节 总结目前 Python2 与 Python3 是并存的，因此在编写代码过程中需要注意其中的差异和兼容性，不然就要出锅了hhh（虽然 Python2 在 2020 年 1 月就要停止维护了）。 参考 字符编码笔记 Unicode In Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中异步获取文件集并返回结果集]]></title>
    <url>%2F2019%2F01%2F20%2Fjs%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E9%9B%86%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[概述最近在使用js中经常遇到需要去异步获取文件并对文件内容进行处理的需求。 详细的需求是：同时去异步获取多个文件，然后将多个文件的结果聚合起来，返回。 但是关于这样的做法有不少的实现方式，在这里主要做一个总结。 做法我先在项目中放置了两个需要获取的json文件。 a.json 1234&#123; "a": "1", "b": "2"&#125; b.json 1234&#123; "c": "3", "d": "4"&#125; 接下来开始获取这两个文件。 只使用 Promise/thenPromise/then介绍Promise介绍 关于 Promise，可以看上面的链接，介绍的十分详细。 Promise有一个resolve()方法，将Promise对象的pending状态转化为resolved状态，并将操作的结果作为参数传递出去：例如 new Promise((resolve, reject) =&gt; { resolve(&#39;123&#39;) })，这里会将&#39;123&#39;作为Promise的结果传递出去。 接着可以用then方法去获取结果。then方法只能跟在Promise的后面，因此then方法的两个形参分别是Promise的resolve()方法传入的参数和reject()方法传入的参数。 一个小例子： 123let promise = new Promise((resolve, reject) =&gt; &#123; resolve('123') &#125;)promise.then(data =&gt; console.log(data))// 123 实现异步123456789101112131415161718192021222324252627282930313233let files = ['./data/a.json', './data/b.json'] // 放在相对于index.html目录下的两个json文件let promises = files.map((file) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(file).then((resp) =&gt; &#123; resolve(resp.json()) // resp.json() is a promise，resolve(resp.json())将包含的文件结果的promise传递出去 &#125;) &#125;)&#125;)console.log('A : ', promises) // two promises/*A : (2) [Promise, Promise] 0: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: Object a: "1" b: "2" 1: Promise &#123;&lt;resolved&gt;: &#123;…&#125;&#125; length: 2*/// Promise.all()将promises数组转化为一个promise，并获取promises内部的promise的返回值，并将返回值以一个数组的形式传递出去Promise.all(promises).then((results) =&gt; &#123; console.log(results) &#125;)/*(2) [&#123;…&#125;, &#123;…&#125;] 0: a: "1" b: "2" 1: c: "3" d: "4" length: 2*/ 使用async/await使用async函数之前可能还需要了解一下Generator函数。 Generator函数介绍Generator函数不同于普通的函数。它在函数名前面会有一个*的标志，而且内部可以使用yeild使得Generator函数具有一些状态，不会一次执行完毕。 Generator函数可以通过调用next()方法执行到下一个yeild，每次会返回一个包含{value: , done: }的对象，为yeild后面的表达式的结果。可以给next()函数传递值，使得这个值为上一个yeild表达式的返回结果。 123456789101112131415function* genFunc() &#123; let resA = yield '1' console.log(resA) let resB = yield '2' console.log(resB) return '3'&#125;// 此时还未执行gen()let gen = genFunc()// 开始执行第一个yield(yield '1')console.log(gen.next())// 执行第二个yeild(yield '2')，传入的参数为上一个yield的返回值，因此genFunc()中的resA='A'console.log(gen.next('A'))// 执行第三个yeild(return '3')，resB的值与上面同理console.log(gen.next('B')) 结果： async/await介绍async函数介绍 async/await主要是将Generator函数的*替换为async，将yield替换为await，而且await后面需要跟promise，并且等待其执行完成，得到其执行结果；如果不是promise的话，会立即返回其值。另外async函数的返回值是一个promise。 实现异步123456789let files = ['./data/a.json', './data/b.json']async function fetchFilesData(files) &#123; let promises = files.map(async (file) =&gt; &#123; let resp = await fetch(file) // 此时await等待fetch的结果，但是这个过程是并发fetch return resp.json() &#125;) return await Promise.all(promises) // 此时await等待并获取了Promise.all()的执行结果&#125;fetchFilesData(files).then((results) =&gt; &#123; console.log(results) &#125;) // 最后这里还是用.then()去获取，不知道是否存在不用.then()的方法 结果： 使用axios替代fetch听同学说用axios替代fetch会更好，经过查阅资料，主要是有axios从浏览器中创建 XMLHttpRequest，然而fetch是es规范中的实现方式，脱离了XMLHttpRequest，需要更多的配置。具体其他的区别需要在其他使用场景中去注意。 下面是两个方法的返回值的区别： 123let files = ['./data/a.json', './data/b.json']console.log('fetch:', fetch(files[0]))console.log('axios:', axios.get(files[0])) 结果： 可以看到两者的区别。 实现异步123456789let files = ['./data/a.json', './data/b.json']async function fetchFilesData(files) &#123; let promises = files.map((file) =&gt; &#123; return axios.get(file) // 得到一个返回response的promise &#125;) return await Promise.all(promises)&#125;fetchFilesData(files).then((results) =&gt; &#123; return results.map((result) =&gt; &#123;return result.data&#125;) &#125;) .then((data) =&gt; &#123;console.log(data)&#125;) 总结对于不同实现方式的优点和缺点，以及原理尚还不是很清晰，特别是axios和fetch两者，还需要再多多学习。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>问题记录</tag>
        <tag>JavaScipt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端css样式覆盖问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%89%8D%E7%AB%AFcss%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[综述今天在使用 D3 的时候遇到一个 css 的问题，这里留作记录防止以后踩坑。 问题在使用 d3 添加鼠标响应事件，想要修改 css，结果不会修改。 123456789101112131415let rec = svg.append("rect") .attr("class", "view") .attr("x", 1) .attr("y", 1) .attr("width", width - 2) .attr("height", height - 2) .attr("fill", "gray") .style("stroke", "red") .style("stroke-width", "2px") .on("mouseover", function() &#123; d3.select(this).classed("hover", true) &#125;) .on("mouseout", function() &#123; d3.select(this).classed("hover", false) &#125;) 12345678910.view:hover &#123; stroke: blue; stroke-width: 2;&#125;.view &#123; stroke: gold; stroke-width: 2; pointer-events: all;&#125; 这里添加了 mouseover 和 mouseout 事件，借此改变 rect 的样式，结果没有成功。 解决方法折腾了好久，问了一下大佬立马解决。 打开 chrome 的调试工具。 可以看到这里 .view:hover 和 .view 都是被 element.style 覆盖了。 这个 element.style 一般是内联样式，因此查看自己的代码，发现在定义 rect 的时候已经定义了 style ： .style(&quot;stroke&quot;, &quot;red&quot;).style(&quot;stroke-width&quot;, &quot;2px&quot;)。 将这两句去掉，可以得到最终结果： hover unhover 完整代码 D3Component.js 12345678910111213141516171819202122232425262728293031323334353637import React from 'react';import * as d3 from 'd3';import './D3Component.css'class D3Component extends React.Component &#123; componentDidMount() &#123; let svg = d3.select("svg"), width = +svg.attr("width"), height = +svg.attr("height"); let rec = svg.append("rect") .attr("class", "view") .attr("x", 1) .attr("y", 1) .attr("width", width - 2) .attr("height", height - 2) .attr("fill", "gray") // .style("stroke", "red") // .style("stroke-width", "2px") .on("mouseover", function() &#123; d3.select(this).classed("hover", true) &#125;) .on("mouseout", function() &#123; d3.select(this).classed("hover", false) &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;svg id="svg" width="100" height="100"&gt;&lt;/svg&gt; &lt;/div&gt; ) &#125;&#125;export default D3Component; D3Component.css 12345678910.view:hover &#123; stroke: blue; stroke-width: 2;&#125;.view &#123; stroke: gold; stroke-width: 2; pointer-events: all;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>问题记录</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F15%2FHello-World%2F</url>
    <content type="text"><![CDATA[本人是广东某双非本科的计算机系蒟蒻一枚，大一到大三接触过ACM，之后开始接触Java备战春招，暑假在杭州实习。虽然秋招以Java后台开发为目标，但是去了广州某无人驾驶公司，主要使用Python（学了一年的Java最终丢了233）。之前一直是用博客园和简书写一些东西，前两周入职了，开始接触新的东西，建立这个博客也算是新的启程吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
