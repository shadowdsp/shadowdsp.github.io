<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js中异步获取文件集并返回结果集]]></title>
    <url>%2F2019%2F01%2F20%2Fjs%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E9%9B%86%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[概述最近在使用js中经常遇到需要去异步获取文件并对文件内容进行处理的需求。 详细的需求是：同时去异步获取多个文件，然后将多个文件的结果聚合起来，返回。 但是关于这样的做法有不少的实现方式，在这里主要做一个总结。 做法我先在项目中放置了两个需要获取的json文件。 a.json 1234&#123; "a": "1", "b": "2"&#125; b.json 1234&#123; "c": "3", "d": "4"&#125; 接下来开始获取这两个文件。 只使用 Promise/thenPromise/then介绍Promise介绍 关于 Promise，可以看上面的链接，介绍的十分详细。 Promise有一个resolve()方法，将Promise对象的pending状态转化为resolved状态，并将操作的结果作为参数传递出去：例如 new Promise((resolve, reject) =&gt; { resolve(&#39;123&#39;) })，这里会将&#39;123&#39;作为Promise的结果传递出去。 接着可以用then方法去获取结果。then方法只能跟在Promise的后面，因此then方法的两个形参分别是Promise的resolve()方法传入的参数和reject()方法传入的参数。 一个小例子： 123let promise = new Promise((resolve, reject) =&gt; &#123; resolve('123') &#125;)promise.then(data =&gt; console.log(data))// 123 实现异步123456789101112131415161718192021222324252627282930313233let files = ['./data/a.json', './data/b.json'] // 放在相对于index.html目录下的两个json文件let promises = files.map((file) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(file).then((resp) =&gt; &#123; resolve(resp.json()) // resp.json() is a promise，resolve(resp.json())将包含的文件结果的promise传递出去 &#125;) &#125;)&#125;)console.log('A : ', promises) // two promises/*A : (2) [Promise, Promise] 0: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: Object a: "1" b: "2" 1: Promise &#123;&lt;resolved&gt;: &#123;…&#125;&#125; length: 2*/// Promise.all()将promises数组转化为一个promise，并获取promises内部的promise的返回值，并将返回值以一个数组的形式传递出去Promise.all(promises).then((results) =&gt; &#123; console.log(results) &#125;)/*(2) [&#123;…&#125;, &#123;…&#125;] 0: a: "1" b: "2" 1: c: "3" d: "4" length: 2*/ 使用async/await使用async函数之前可能还需要了解一下Generator函数。 Generator函数介绍Generator函数不同于普通的函数。它在函数名前面会有一个*的标志，而且内部可以使用yeild使得Generator函数具有一些状态，不会一次执行完毕。 Generator函数可以通过调用next()方法执行到下一个yeild，每次会返回一个包含{value: , done: }的对象，为yeild后面的表达式的结果。可以给next()函数传递值，使得这个值为上一个yeild表达式的返回结果。 123456789101112131415function* genFunc() &#123; let resA = yield '1' console.log(resA) let resB = yield '2' console.log(resB) return '3'&#125;// 此时还未执行gen()let gen = genFunc()// 开始执行第一个yield(yield '1')console.log(gen.next())// 执行第二个yeild(yield '2')，传入的参数为上一个yield的返回值，因此genFunc()中的resA='A'console.log(gen.next('A'))// 执行第三个yeild(return '3')，resB的值与上面同理console.log(gen.next('B')) 结果： async/await介绍async函数介绍 async/await主要是将Generator函数的*替换为async，将yield替换为await，而且await后面需要跟promise，并且等待其执行完成，得到其执行结果；如果不是promise的话，会立即返回其值。另外async函数的返回值是一个promise。 实现异步123456789let files = ['./data/a.json', './data/b.json']async function fetchFilesData(files) &#123; let promises = files.map(async (file) =&gt; &#123; let resp = await fetch(file) // 此时await等待fetch的结果，但是这个过程是并发fetch return resp.json() &#125;) return await Promise.all(promises) // 此时await等待并获取了Promise.all()的执行结果&#125;fetchFilesData(files).then((results) =&gt; &#123; console.log(results) &#125;) // 最后这里还是用.then()去获取，不知道是否存在不用.then()的方法 结果： 使用axios替代fetch听同学说用axios替代fetch会更好，经过查阅资料，主要是有axios从浏览器中创建 XMLHttpRequest，然而fetch是es规范中的实现方式，脱离了XMLHttpRequest，需要更多的配置。具体其他的区别需要在其他使用场景中去注意。 下面是两个方法的返回值的区别： 123let files = ['./data/a.json', './data/b.json']console.log('fetch:', fetch(files[0]))console.log('axios:', axios.get(files[0])) 结果： 可以看到两者的区别。 实现异步123456789let files = ['./data/a.json', './data/b.json']async function fetchFilesData(files) &#123; let promises = files.map((file) =&gt; &#123; return axios.get(file) // 得到一个返回response的promise &#125;) return await Promise.all(promises)&#125;fetchFilesData(files).then((results) =&gt; &#123; return results.map((result) =&gt; &#123;return result.data&#125;) &#125;) .then((data) =&gt; &#123;console.log(data)&#125;) 总结对于不同实现方式的优点和缺点，以及原理尚还不是很清晰，特别是axios和fetch两者，还需要再多多学习。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>问题记录</tag>
        <tag>JavaScipt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端css样式覆盖问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%89%8D%E7%AB%AFcss%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[综述今天在使用 D3 的时候遇到一个 css 的问题，这里留作记录防止以后踩坑。 问题在使用 d3 添加鼠标响应事件，想要修改 css，结果不会修改。 123456789101112131415let rec = svg.append("rect") .attr("class", "view") .attr("x", 1) .attr("y", 1) .attr("width", width - 2) .attr("height", height - 2) .attr("fill", "gray") .style("stroke", "red") .style("stroke-width", "2px") .on("mouseover", function() &#123; d3.select(this).classed("hover", true) &#125;) .on("mouseout", function() &#123; d3.select(this).classed("hover", false) &#125;) 12345678910.view:hover &#123; stroke: blue; stroke-width: 2;&#125;.view &#123; stroke: gold; stroke-width: 2; pointer-events: all;&#125; 这里添加了 mouseover 和 mouseout 事件，借此改变 rect 的样式，结果没有成功。 解决方法折腾了好久，问了一下大佬立马解决。 打开 chrome 的调试工具。 可以看到这里 .view:hover 和 .view 都是被 element.style 覆盖了。 这个 element.style 一般是内联样式，因此查看自己的代码，发现在定义 rect 的时候已经定义了 style ： .style(&quot;stroke&quot;, &quot;red&quot;).style(&quot;stroke-width&quot;, &quot;2px&quot;)。 将这两句去掉，可以得到最终结果： hover unhover 完整代码 D3Component.js 12345678910111213141516171819202122232425262728293031323334353637import React from 'react';import * as d3 from 'd3';import './D3Component.css'class D3Component extends React.Component &#123; componentDidMount() &#123; let svg = d3.select("svg"), width = +svg.attr("width"), height = +svg.attr("height"); let rec = svg.append("rect") .attr("class", "view") .attr("x", 1) .attr("y", 1) .attr("width", width - 2) .attr("height", height - 2) .attr("fill", "gray") // .style("stroke", "red") // .style("stroke-width", "2px") .on("mouseover", function() &#123; d3.select(this).classed("hover", true) &#125;) .on("mouseout", function() &#123; d3.select(this).classed("hover", false) &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;svg id="svg" width="100" height="100"&gt;&lt;/svg&gt; &lt;/div&gt; ) &#125;&#125;export default D3Component; D3Component.css 12345678910.view:hover &#123; stroke: blue; stroke-width: 2;&#125;.view &#123; stroke: gold; stroke-width: 2; pointer-events: all;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>问题记录</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F15%2FHello-World%2F</url>
    <content type="text"><![CDATA[本人是广东某双非本科的计算机系蒟蒻一枚，大一到大三接触过ACM，之后开始接触Java备战春招，暑假在杭州实习。虽然秋招以Java后台开发为目标，但是去了广州某无人驾驶公司，主要使用Python（学了一年的Java最终丢了233）。之前一直是用博客园和简书写一些东西，前两周入职了，开始接触新的东西，建立这个博客也算是新的启程吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
